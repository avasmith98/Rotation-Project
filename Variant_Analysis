import sys
import io
import datetime
import requests
import re
from bs4 import BeautifulSoup
from urllib.parse import quote
from reportlab.lib.pagesizes import letter
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, Table, TableStyle
from reportlab.lib.units import inch
from reportlab.lib import colors
from xml.etree import ElementTree as ET
from flask import Flask, request, render_template_string
import threading

gene_symbol = ""
hgvs_cdna_transcript_id = ""

def send_request(url, headers=None, params=None):
    try:
        response = requests.get(url, headers=headers, params=params)
        response.raise_for_status()
        return response
    except requests.RequestException as e:
        print(f"Failed to retrieve data from {url}: {e}")
        return None

def capture_output_and_return_value(func, *args, **kwargs):
    with io.StringIO() as output_buffer:
        sys.stdout = output_buffer
        result = func(*args, **kwargs)
        sys.stdout = sys.__stdout__
        return output_buffer.getvalue(), result

def split_and_style(line, normal_style):
    parts = line.split(':', 1)
    if len(parts) > 1:
        return Paragraph(f"<b>{parts[0]}:</b> {parts[1].strip()}", normal_style)
    return Paragraph(line, normal_style)

def create_pdf_from_text(text, output_path, protein_domains, clinvar_data, hgvs_cdna_transcript_id, most_recent_hgvs_cdna_transcript_id):
    styles = getSampleStyleSheet()
    normal_style = styles['Normal']
    header_style = ParagraphStyle(name='HeaderStyle', parent=styles['Heading1'], fontSize=14, spaceAfter=10)
    table_header_style = ParagraphStyle(name='TableHeaderStyle', parent=styles['Normal'], fontSize=12, fontName='Helvetica-Bold', alignment=1)
    doc = SimpleDocTemplate(output_path, pagesize=letter, rightMargin=72, leftMargin=72, topMargin=72, bottomMargin=72)
    story = []

    for line in text.splitlines():
        if line.startswith("Variant Analysis Report:"):
            story.append(Paragraph(line, header_style))
        elif line.startswith("Report generated on"):
            story.append(Paragraph(line, normal_style))
        elif any(line.startswith(prefix) for prefix in ["Cytogenetic band:", "High protein expression:", "Transcript length:", "Translation length:", "Total number of exons:", "Number of coding exons:", "Variant location:"]):
            story.append(Paragraph(line, normal_style))
        elif line.startswith("Source:"):
            story.append(Paragraph(line, normal_style))
        else:
            story.append(Paragraph(line, normal_style))
        story.append(Spacer(1, 12))

    # Add HGVS cDNA transcript IDs
    story.append(Paragraph(f"<b>HGVS cDNA Transcript ID:</b> {hgvs_cdna_transcript_id}", normal_style))
    story.append(Spacer(1, 12))
    story.append(Paragraph(f"<b>Most Recent HGVS cDNA Transcript ID:</b> {most_recent_hgvs_cdna_transcript_id}", normal_style))
    story.append(Spacer(1, 12))

    # Add protein domains table
    if protein_domains:
        story.append(Paragraph("Protein Domain(s):", header_style))
        story.append(Spacer(1, 12))
        data = [[Paragraph("Source", table_header_style), Paragraph("Description", table_header_style), Paragraph("Start", table_header_style), Paragraph("End", table_header_style)]]
        for domain in protein_domains:
            data.append([domain["Source"], Paragraph(domain["Description"], styles['BodyText']), domain["Start"], domain["End"]])
        table = Table(data, colWidths=[1.0 * inch, 3.0 * inch, 1.0 * inch, 1.0 * inch], hAlign='LEFT')
        table.setStyle(TableStyle([('BACKGROUND', (0, 0), (-1, 0), colors.grey), ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke), ('ALIGN', (0, 0), (-1, -1), 'LEFT'), ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'), ('FONTSIZE', (0, 0), (-1, 0), 12), ('BOTTOMPADDING', (0, 0), (-1, 0), 12), ('BACKGROUND', (0, 1), (-1, -1), colors.beige), ('GRID', (0, 0), (-1, -1), 1, colors.black), ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'), ('LEFTPADDING', (0, 0), (-1, -1), 5), ('RIGHTPADDING', (0, 0), (-1, -1), 5)]))
        story.append(table)
        story.append(Spacer(1, 12))
    else:
        story.append(Paragraph("Protein Domain(s): Search Successful - No domains found", normal_style))
        story.append(Spacer(1, 12))

    # Add ClinVar data table
    if clinvar_data:
        story.append(Paragraph("ClinVar:", header_style))
        story.append(Spacer(1, 12))
        data = [[Paragraph("Variant classification", table_header_style), Paragraph("Variant condition", table_header_style), Paragraph("Variant more info", table_header_style)]]
        for item in clinvar_data:
            data.append([Paragraph(item["Variant classification"], normal_style), Paragraph(item["Variant condition"], normal_style), Paragraph(item["Variant more info"], styles['BodyText'])])
        table = Table(data, colWidths=[1.5 * inch, 1.5 * inch, 3.5 * inch], hAlign='LEFT')
        table.setStyle(TableStyle([('BACKGROUND', (0, 0), (-1, 0), colors.grey), ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke), ('ALIGN', (0, 0), (-1, -1), 'LEFT'), ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'), ('FONTSIZE', (0, 0), (-1, 0), 12), ('BOTTOMPADDING', (0, 0), (-1, 0), 12), ('BACKGROUND', (0, 1), (-1, -1), colors.beige), ('GRID', (0, 0), (-1, -1), 1, colors.black), ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'), ('LEFTPADDING', (0, 0), (-1, -1), 5), ('RIGHTPADDING', (0, 0), (-1, -1), 5)]))
        story.append(table)
        story.append(Spacer(1, 12))
    else:
        story.append(Paragraph("ClinVar Data: No data found", normal_style))
        story.append(Spacer(1, 12))

    try:
        doc.build(story)
        print(f"PDF successfully created at {output_path}")
    except PermissionError as e:
        print(f"Error: {e}")
        print(f"Permission denied. The file '{output_path}' might be open in another application. Please close the file and try again.")

def get_full_gene_name(gene_symbol):
    url = f"https://rest.ensembl.org/lookup/symbol/homo_sapiens/{gene_symbol}"
    headers = {"Content-Type": "application/json"}
    response = send_request(url, headers=headers)
    if response:
        description = response.json().get("description", "Full gene name not available")
        match = re.match(r"([^[]+)", description)
        return match.group(1).strip() if match else "Full gene name not available"
    return f"Failed to retrieve data for {gene_symbol}"

def print_header(gene_symbol):
    full_gene_name = get_full_gene_name(gene_symbol)
    header = f"Variant Analysis Report: {gene_symbol} ({full_gene_name})\nReport generated on {datetime.date.today().strftime('%B %d, %Y')}"
    print(header)

def truncate_hgvs_cdna_transcript_id(hgvs_cdna_transcript_id):
    return hgvs_cdna_transcript_id.split(':')[0].split('.')[0]

def get_cytogenetic_band(gene_symbol):
    search_url = f'https://api.genome.ucsc.edu/search?search={gene_symbol}&genome=hg38'
    search_response = send_request(search_url)
    search_data = search_response.json() if search_response else {}
    try:
        for match in search_data['positionMatches'][0]['matches']:
            if gene_symbol in match['posName'] and 'ENST' in match['hgFindMatches']:
                position = match['position']
                chrom, pos_range = position.split(':')
                start, end = pos_range.split('-')
                track_url = f'https://api.genome.ucsc.edu/getData/track?track=cytoBand;genome=hg38;chrom={chrom};start={start};end={end}'
                track_response = send_request(track_url)
                track_data = track_response.json() if track_response else {}
                cytogenetic_band = track_data.get('cytoBand', 'Band not found')
                chromosome = cytogenetic_band[0]['chrom'][3:]
                cytoband = cytogenetic_band[0]['name']
                return chromosome + cytoband
    except (IndexError, KeyError) as e:
        print(f"Error handling API response: {e}")
        return "Gene symbol not found or data incomplete."

def get_ensembl_gene_id(gene_symbol):
    url = f"https://rest.ensembl.org/lookup/symbol/homo_sapiens/{gene_symbol}"
    headers = {"Content-Type": "application/json"}
    response = send_request(url, headers)
    return response.json().get("id") if response else None

def get_high_protein_expression(ensembl_gene_id):
    url = f"https://www.proteinatlas.org/{ensembl_gene_id}.xml"
    response = send_request(url)
    high_protein_expression = []
    if response:
        root = ET.fromstring(response.content)
        for data in root.findall(".//data"):
            tissue = data.find('tissue')
            levels = data.findall('level[@type="expression"]')
            if tissue is not None and any(level.text.strip().lower() == "high" for level in levels):
                high_protein_expression.append(tissue.text)
    return high_protein_expression if high_protein_expression else ["Protein not highly expressed"]

def get_ensembl_transcript_id(hgvs_cdna_transcript_id_truncated):
    url = f"https://rest.ensembl.org/xrefs/symbol/homo_sapiens/{hgvs_cdna_transcript_id_truncated}?external_db=RefSeq_mRNA"
    headers = {"Content-Type": "application/json"}
    response = send_request(url, headers)
    if response:
        data = response.json()
        for entry in data:
            if entry['type'] == 'transcript':
                return entry['id']
    return None

def get_current_version_hgvs_cdna_transcript_id(hgvs_cdna_transcript_id):
    hgvs_cdna_transcript_id_truncated = truncate_hgvs_cdna_transcript_id(hgvs_cdna_transcript_id)
    fetch_url = f"https://eutils.ncbi.nlm.nih.gov/entrez/eutils/efetch.fcgi?db=nucleotide&id={hgvs_cdna_transcript_id_truncated}&rettype=gb&retmode=xml"
    response = send_request(fetch_url)
    if response:
        root = ET.fromstring(response.content)
        return next((item.find('GBSeq_accession-version').text for item in root.findall('.//GBSeq')), None)
    return None

def get_grch38_variant_position(hgvs_cdna_transcript_id):
    def fetch_position(hgvs_cdna_transcript_id):
        url = f"https://www.ncbi.nlm.nih.gov/snp/?term={quote(hgvs_cdna_transcript_id)}"
        response = send_request(url)
        if response:
            soup = BeautifulSoup(response.text, 'html.parser')
            for dt in soup.find_all('dt'):
                if dt.text.strip() == "Chromosome:":
                    dd_tag = dt.find_next('dd')
                    entries = dd_tag.decode_contents().split('<br/>')
                    for entry in entries:
                        if "GRCh38" in entry:
                            entry_clean = BeautifulSoup(entry, 'html.parser').text.strip()
                            return ''.join(filter(str.isdigit, entry_clean.split(' ')[-1].replace('GRCh38', '').strip()))
        return None

    position = fetch_position(hgvs_cdna_transcript_id)
    if position:
        return position
    current_version = get_current_version_hgvs_cdna_transcript_id(hgvs_cdna_transcript_id.split(':')[0])
    if current_version:
        return fetch_position(f"{current_version}:{hgvs_cdna_transcript_id.split(':')[1]}")
    return "GRCh38 chromosome information not found"

def get_transcript_details_and_ensembl_protein_id(ensembl_transcript_id, variant_position):
    url = f"https://rest.ensembl.org/lookup/id/{ensembl_transcript_id}?expand=1"
    headers = {"Content-Type": "application/json"}
    response = send_request(url, headers)
    if response:
        data = response.json()
        translation = data.get('Translation', {})
        coding_exons = [exon for exon in data.get('Exon', []) if exon['start'] <= translation.get('end', 0) and exon['end'] >= translation.get('start', float('inf'))]
        exon_number = next((index for index, exon in enumerate(data.get('Exon', []), start=1) if exon['start'] <= variant_position <= exon['end']), None)
        return {
            "transcript_length": data.get('length', 'Transcript Length not available'),
            "translation_length": translation.get('length', 'Translation length not available'),
            "total_exons": len(data.get('Exon', [])),
            "coding_exons": len(coding_exons),
            "exon_number": exon_number,
            "ensembl_protein_id": translation['id']
        }
    return None

def get_protein_domains(ensembl_protein_id):
    url = f"https://rest.ensembl.org/overlap/translation/{ensembl_protein_id}"
    headers = {"Content-Type": "application/json"}
    response = send_request(url, headers)
    domains = []
    if response:
        for domain in response.json():
            if domain.get('type') in ['Pfam', 'Smart']:
                domains.append({
                    "Source": domain['type'],
                    "Description": domain.get('description', 'No description available'),
                    "Start": domain['start'],
                    "End": domain['end']
                })
    if not domains:
        domains.append({
            "Source": "Retrieval successful - No domains found",
            "Description": "",
            "Start": "",
            "End": ""
        })
    return domains

def get_rsID(hgvs_cdna_transcript_id):
    def fetch_rsid(hgvs_cdna_transcript_id):
        url = "https://www.ncbi.nlm.nih.gov/snp/"
        response = send_request(url, params={'term': hgvs_cdna_transcript_id})
        if response:
            soup = BeautifulSoup(response.text, 'html.parser')
            rsid_link = soup.find('a', href=lambda href: href and '/snp/rs' in href)
            if rsid_link:
                return rsid_link.text.strip()
        return None

    rsID = fetch_rsid(hgvs_cdna_transcript_id)
    if rsID:
        return rsID
    current_version = get_current_version_hgvs_cdna_transcript_id(hgvs_cdna_transcript_id.split(':')[0])
    if current_version:
        return fetch_rsid(f"{current_version}:{hgvs_cdna_transcript_id.split(':')[1]}")
    return "rsID not found"

def get_clinvar_data(rsID):
    url = f"https://www.ncbi.nlm.nih.gov/clinvar/?term={rsID}"
    response = send_request(url)
    extracted_data = []
    if response:
        soup = BeautifulSoup(response.text, 'html.parser')
        tables = soup.find_all('table')
        if len(tables) > 4:
            rows = tables[4].find_all('tr')
            for row in rows:
                cells = row.find_all('td')
                if len(cells) >= 5:
                    classification_info = cells[0].text.strip()
                    condition_info = cells[2].text.strip()
                    more_info = cells[4].text.strip().split("(more)")[1].strip() if "(more)" in cells[4].text else cells[4].text.strip()
                    extracted_data.append({'Variant classification': classification_info, 'Variant condition': condition_info, 'Variant more info': more_info})
            if not extracted_data:
                extracted_data.append({'Variant classification': 'No data', 'Variant condition': 'No data', 'Variant more info': 'No data'})
        else:
            extracted_data.append({'Variant classification': 'No ClinVar submissions found for this rsID.', 'Variant condition': '', 'Variant more info': ''})
    else:
        extracted_data.append({'Variant classification': 'Failed to retrieve data from ClinVar.', 'Variant condition': '', 'Variant more info': ''})
    return extracted_data

def program(gene_symbol, hgvs_cdna_transcript_id):
    print_header(gene_symbol)
    ensembl_gene_id = get_ensembl_gene_id(gene_symbol)
    hgvs_cdna_transcript_id_truncated = truncate_hgvs_cdna_transcript_id(hgvs_cdna_transcript_id)
    results = {
        "cytogenetic_band": get_cytogenetic_band(gene_symbol),
        "high_protein_expression": get_high_protein_expression(ensembl_gene_id),
        "ensembl_transcript_id": get_ensembl_transcript_id(hgvs_cdna_transcript_id_truncated),
        "variant_position": int(get_grch38_variant_position(hgvs_cdna_transcript_id)),
        "most_recent_hgvs_cdna_transcript_id": get_current_version_hgvs_cdna_transcript_id(hgvs_cdna_transcript_id)
    }
    transcript_details = get_transcript_details_and_ensembl_protein_id(results["ensembl_transcript_id"], results["variant_position"])
    results.update(transcript_details)
    results["protein_domains"] = get_protein_domains(results["ensembl_protein_id"])
    results["rsID"] = get_rsID(hgvs_cdna_transcript_id)
    results["clinvar_data"] = get_clinvar_data(results["rsID"])
    
    print(f"Cytogenetic band: {results['cytogenetic_band']}")
    print(f"High protein expression: {', '.join(results['high_protein_expression'])}")
    print(f"Transcript length: {results['transcript_length']}")
    print(f"Translation length: {results['translation_length']}")
    print(f"Total number of exons: {results['total_exons']}")
    print(f"Number of coding exons: {results['coding_exons']}")
    print(f"Variant location: exon {results['exon_number']} of {results['coding_exons']}")

    return results["protein_domains"], results["clinvar_data"], hgvs_cdna_transcript_id, results["most_recent_hgvs_cdna_transcript_id"]

# HTML template for the form
html_template = """
<!DOCTYPE html>
<html>
<head>
    <title>Gene Variant PDF Generator</title>
</head>
<body>
    <h1>Gene Variant PDF Generator</h1>
    <form method="POST">
        Gene Symbol: <input type="text" name="gene_symbol"><br><br>
        HGVS cDNA Transcript ID: <input type="text" name="hgvs_cdna_transcript_id"><br><br>
        <input type="submit" value="Generate PDF">
    </form>
    {% if output %}
    <h2>Output:</h2>
    <pre>{{ output }}</pre>
    {% endif %}
</body>
</html>
"""

# Create Flask app
app = Flask(__name__)

@app.route('/', methods=['GET', 'POST'])
def index():
    output = None
    if request.method == 'POST':
        gene_symbol = request.form['gene_symbol']
        hgvs_cdna_transcript_id = request.form['hgvs_cdna_transcript_id']
        output_pdf_file_path = f"{gene_symbol}.pdf"
        
        # Capture the output and get the result
        captured_text, (protein_domains, clinvar_data, hgvs_cdna_transcript_id, most_recent_hgvs_cdna_transcript_id) = capture_output_and_return_value(
            program, gene_symbol=gene_symbol, hgvs_cdna_transcript_id=hgvs_cdna_transcript_id)
        
        # Create the PDF
        create_pdf_from_text(captured_text, output_pdf_file_path, protein_domains, clinvar_data, hgvs_cdna_transcript_id, most_recent_hgvs_cdna_transcript_id)
        
        # Suppress detailed output and display confirmation message
        output = f"PDF generated successfully: {output_pdf_file_path}"
    
    return render_template_string(html_template, output=output)

def run_flask_app():
    app.run(debug=True, use_reloader=False)

# Run Flask app in a separate thread
flask_thread = threading.Thread(target=run_flask_app)
flask_thread.start()
