import sys
import io
import datetime
import requests
import os
import re
import threading
from bs4 import BeautifulSoup
from urllib.parse import quote
from reportlab.lib.pagesizes import letter
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, PageBreak, Spacer, Paragraph, Frame
from reportlab.lib.units import inch
from reportlab.lib import colors
from flask import Flask, request, render_template_string, send_file
from xml.etree import ElementTree as ET

def send_request(url, headers=None):
    try:
        response = requests.get(url, headers=headers)
        response.raise_for_status()
        return response
    except: 
        return(f'Failed to retrieve data from {url}')

def get_report_date():
    report_date = datetime.date.today().strftime('%B %d, %Y')
    return report_date
    
def truncate_hgvs_cdna_transcript_id(hgvs_cdna_transcript_id):
    hgvs_cdna_transcript_id_truncated = hgvs_cdna_transcript_id.split(':')[0].split('.')[0]
    return hgvs_cdna_transcript_id_truncated

def split_hgvs_cdna_transcript_id(hgvs_cdna_transcript_id):
    split_hgvs_cdna_transcript_id = hgvs_cdna_transcript_id.split(':')[1]
    return split_hgvs_cdna_transcript_id

def get_ensembl_transcript_id(hgvs_cdna_transcript_id_truncated):
    url = f'https://rest.ensembl.org/xrefs/symbol/homo_sapiens/{hgvs_cdna_transcript_id_truncated}?external_db=RefSeq_mRNA'
    headers = {'Content-Type': 'application/json'}
    response = send_request(url, headers)
    if response:
        try: 
            data = response.json()
            for entry in data:
                if entry['type'] == 'transcript':
                    ensembl_transcript_id = entry['id']
                    return ensembl_transcript_id
        except:
            return(f'Retrieval from {url} successful. Error handling response.') 

def get_gene_symbol(ensembl_transcript_id):
    url = f"https://rest.ensembl.org/lookup/id/{ensembl_transcript_id}"
    headers = {"Content-Type": "application/json"}
    response = send_request(url, headers)
    if response:
        try:
            data = response.json()
            gene_symbol = data.get('display_name')
            gene_symbol = gene_symbol.split('-')[0]
            return gene_symbol
        except:
            return(f'Retrieval from {url} successful. Error handling response.') 

def get_full_gene_name(gene_symbol):
    url = f"https://rest.ensembl.org/lookup/symbol/homo_sapiens/{gene_symbol}"
    headers = {"Content-Type": "application/json"}
    response = requests.get(url, headers=headers)
    if response:
        try:
            data = response.json()
            description = data.get("description")
            match = re.match(r"([^[]+)", description)
            full_gene_name = match.group(1).strip()
            return full_gene_name
        except:
            return(f'Retrieval from {url} successful. Error handling response.') 

def get_gene_start_end_chromosome(gene_symbol):
    url = f'https://api.genome.ucsc.edu/search?search={gene_symbol}&genome=hg38'
    response = requests.get(url)
    if response:
        try:
            data = response.json()
            for match in data['positionMatches'][0]['matches']:
                if gene_symbol in match['posName'] and 'ENST' in match['hgFindMatches']:
                    position = match['position']
                    chromosome, pos_range = position.split(':')
                    start, end = pos_range.split('-')
                    return chromosome, start, end
        except:
            return(f'Retrieval from {url} successful. Error handling response.') 
        
def get_cytogenetic_band(gene_symbol, chromosome, start, end):
    url = f'https://api.genome.ucsc.edu/getData/track?track=cytoBand;genome=hg38;chrom={chromosome};start={start};end={end}'
    response = requests.get(url)
    if response:
        try:
            data = response.json()
            cytogenetic_band = data.get('cytoBand')
            chromosome = cytogenetic_band[0]['chrom'][3:]
            cytoband = cytogenetic_band[0]['name']
            cytogenetic_band = chromosome + cytoband
            return cytogenetic_band
        except:
            return(f'Retrieval from {url} successful. Error handling response.') 
        
def get_ensembl_gene_id(gene_symbol):
    url = f'https://rest.ensembl.org/lookup/symbol/homo_sapiens/{gene_symbol}'
    headers = {'Content-Type': 'application/json'}
    response = send_request(url, headers)
    if response:
        try:
            data = response.json()
            ensembl_gene_id = data.get('id')
            return ensembl_gene_id
        except:
            return(f'Retrieval from {url} successful. Error handling response.') 

def get_high_protein_expression(ensembl_gene_id):
    url = f'https://www.proteinatlas.org/{ensembl_gene_id}.xml'
    response = send_request(url)
    if response:
        try:
            root = ET.fromstring(response.content)
            high_protein_expression = []
            for data in root.findall('.//data'):
                tissue = data.find('tissue')
                levels = data.findall('level[@type="expression"]')
                if any(level.text.lower() == "high" for level in levels):
                    high_protein_expression.append(tissue.text)
            if high_protein_expression:
                return(', '.join(high_protein_expression).lower())
            return('Protein not highly expressed.')
        except:
            return(f'Retrieval from {url} successful. Error handling response.') 

def get_current_version_hgvs_cdna_transcript_id(hgvs_cdna_transcript_id_truncated):
    url = f'https://eutils.ncbi.nlm.nih.gov/entrez/eutils/efetch.fcgi?db=nucleotide&id={hgvs_cdna_transcript_id_truncated}&rettype=gb&retmode=xml'
    response = requests.get(url)
    if response:
        try:
            root = ET.fromstring(response.content)
            for item in root.findall('.//GBSeq'):
                current_version_hgvs_cdna_transcript_id = item.find('GBSeq_accession-version').text
                return current_version_hgvs_cdna_transcript_id
        except:
            return(f'Retrieval from {url} successful. Error handling response.')

def get_amino_acid_change(current_version_hgvs_cdna_transcript_id, hgvs_cdna_transcript_id_split, ensembl_transcript_id):
    url = f"https://rest.ensembl.org/vep/human/hgvs/{current_version_hgvs_cdna_transcript_id}:{hgvs_cdna_transcript_id_split}"
    headers = {"Content-Type": "application/json"}
    response = send_request(url, headers=headers)
    if response:
        try:
            data = response.json()
            for consequence in data[0]['transcript_consequences']:
                if consequence.get('transcript_id') == ensembl_transcript_id:
                    protein_start = consequence.get('protein_start')
                    protein_end = consequence.get('protein_end', 'Not specified')  
                    amino_acid_change = consequence.get('amino_acids')
            return protein_start, protein_end, amino_acid_change
        except:
            return(f'Retrieval from {url} successful. Error handling response.')

def get_full_current_version_hgvs_cdna_transcript_id(current_version_hgvs_cdna_transcript_id, split_hgvs_cdna_transcript_id):
    full_current_version_hgvs_cdna_transcript_id = current_version_hgvs_cdna_transcript_id + ':' + split_hgvs_cdna_transcript_id
    return full_current_version_hgvs_cdna_transcript_id

def get_grch38_variant_position(current_version_hgvs_cdna_transcript_id):
    url = f'https://www.ncbi.nlm.nih.gov/snp/?term={current_version_hgvs_cdna_transcript_id}'
    response = send_request(url)
    if response:
        try:
            soup = BeautifulSoup(response.text, 'html.parser')
            dt_tags = soup.find_all('dt')
            for dt in dt_tags:
                if dt.text.strip() == 'Chromosome:':
                    dd_tag = dt.find_next('dd')
                    entries = dd_tag.decode_contents().split('<br/>')
                    for entry in entries:
                        if 'GRCh38' in entry:
                            entry_clean = BeautifulSoup(entry, 'html.parser').text.strip()
                            parts = entry_clean.split(' ')
                            for part in parts:
                                if 'GRCh38' in part:
                                    position = part.split(':')[-1].replace('GRCh38', '').strip()
                                    grch38_variant_position = int(''.join(filter(str.isdigit, position)))
                                    return grch38_variant_position
        except:
            return(f'Retrieval from {url} successful. Error handling response.')

def get_transcript_details(ensembl_transcript_id, variant_position):
    url = f'https://rest.ensembl.org/lookup/id/{ensembl_transcript_id}?expand=1'
    headers = {'Content-Type': 'application/json'}
    response = send_request(url, headers)
    if response:
        try:
            data = response.json()
            transcript_length = data.get('length')
            translation = data.get('Translation', {})
            translation_length = translation.get('length')
            total_exons = len(data['Exon']) if 'Exon' in data else 0
            coding_exons = sum(1 for exon in data['Exon'] if exon['start'] <= translation.get('end', 0) and exon['end'] >= translation.get('start', float('inf')))
            exon_number = next((index for index, exon in enumerate(data.get('Exon', []), start=1) if exon['start'] <= variant_position <= exon['end']), None)
            return transcript_length, translation_length, total_exons, coding_exons, exon_number, coding_exons
        except:
            return(f'Retrieval from {url} successful. Error handling response.')

def get_ensembl_protein_id(ensembl_transcript_id):
    url = f'https://rest.ensembl.org/lookup/id/{ensembl_transcript_id}?expand=1'
    headers = {'Content-Type': 'application/json'}
    response = send_request(url, headers)
    if response:
        try:
            data = response.json()
            ensembl_protein_id = data['Translation']['id']
            return ensembl_protein_id
        except:
            return(f'Retrieval from {url} successful. Error handling response.')

def get_pfam_smart_protein_domains(ensembl_protein_id):
    url = f'https://rest.ensembl.org/overlap/translation/{ensembl_protein_id}'
    headers = {'Content-Type': 'application/json'}
    response = send_request(url, headers)
    if response:
        try:
            domain_data = response.json()
            domains = []
            for domain in domain_data:
                if domain.get('type') in ['Pfam', 'Smart']:
                    domains.append({
                        'Source': domain['type'],
                        'Description': domain.get('description'),
                        'Start': str(domain['start']),
                        'End': str(domain['end'])
                    })
            return domains
        except:
            return(f'Retrieval from {url} successful. Error handling response.')

def get_rsID(full_current_version_hgvs_cdna_transcript_id):
    url = f'https://www.ncbi.nlm.nih.gov/snp/?term={full_current_version_hgvs_cdna_transcript_id}'
    response = send_request(url)
    if response:
        try:
            soup = BeautifulSoup(response.text, 'html.parser')
            rsid_link = soup.find('a', href=lambda href: href and '/snp/rs' in href)
            if rsid_link:
                rsID = rsid_link.text.strip()
                return rsID  
        except:
            return(f'Retrieval from {url} successful. Error handling response.')

def get_clinvar(rsID):
    url = f'https://www.ncbi.nlm.nih.gov/clinvar/?term={rsID}'
    response = send_request(url)
    if response:
        try:
            clinvar = []
            soup = BeautifulSoup(response.text, 'html.parser')
            tables = soup.find_all('table')
            if len(tables) > 4:
                correct_table = tables[4]
                rows = correct_table.find_all('tr')
                for row in rows:
                    cells = row.find_all('td')
                    if len(cells) >= 5:
                        classification_info = cells[0].text.strip()
                        condition_info = cells[2].text.strip()
                        more_info = cells[4].text.strip()
                        if '(more)' in more_info:
                            more_info_parts = more_info.split("(more)")
                            if len(more_info_parts) > 1:
                                more_info = more_info_parts[1].strip()
                        if '(less)' in more_info:
                            more_info = more_info.replace('(less)', '').strip()
                        clinvar.append({
                            'Variant classification': classification_info,
                            'Variant condition': condition_info,
                            'Variant more info': more_info
                        })
                        
            cleaned_clinvar = []
            for entry in clinvar:
                cleaned_entry = {}
                for key, value in entry.items():
                    if key == 'Variant classification' or key == 'Variant more info':
                        cleaned_value = ' '.join(value.split())
                        cleaned_entry[key] = cleaned_value
                    elif key == 'Variant condition':
                        parts = [part.strip() for part in value.split('\n') if part.strip()]
                        condition_dict = {}
                        if len(parts) > 0:
                            condition_dict['Condition'] = parts[0]
                        if len(parts) > 1:
                            condition_dict['Affected status'] = parts[1]
                        if len(parts) > 2:
                            condition_dict['Allele origin'] = parts[2]
                        cleaned_entry.update(condition_dict)
                    else:
                        cleaned_entry[key] = value
                cleaned_clinvar.append(cleaned_entry)
            return cleaned_clinvar  
            
            if len(clinvar) < 1:
                raise Exception
            else:
                return cleaned_clinvar
        except Exception:
            try:
                specific_message = f'The following term was not found in ClinVar: {rsID}'
                msg_portlet = soup.find('ul', id='msgportlet')
                message_found = False
                if msg_portlet:
                    li_elements = msg_portlet.find_all('li')
                    for li in li_elements:
                        if specific_message in li.get_text(strip = True):
                            message_found = True
                            break
                    if message_found:
                        return('No ClinVar record associated with this rsID.')
            except Exception:
                return(f'Retrieval from {url} successful. Error handling response.')

def get_results_dict(hgvs_cdna_transcript_id):
    report_date = get_report_date()
    hgvs_cdna_transcript_id_truncated = truncate_hgvs_cdna_transcript_id(hgvs_cdna_transcript_id)
    hgvs_cdna_transcript_id_split = split_hgvs_cdna_transcript_id(hgvs_cdna_transcript_id)
    ensembl_transcript_id = get_ensembl_transcript_id(hgvs_cdna_transcript_id_truncated)
    gene_symbol = get_gene_symbol(ensembl_transcript_id)
    full_gene_name = get_full_gene_name(gene_symbol)
    start, end, chromosome = get_gene_start_end_chromosome(gene_symbol)
    cytogenetic_band = get_cytogenetic_band(gene_symbol, start, end, chromosome)
    ensembl_gene_id = get_ensembl_gene_id(gene_symbol)
    high_protein_expression = get_high_protein_expression(ensembl_gene_id)
    current_version_hgvs_cdna_transcript_id = get_current_version_hgvs_cdna_transcript_id(hgvs_cdna_transcript_id_truncated)
    protein_start, protein_end, amino_acid_change = get_amino_acid_change(current_version_hgvs_cdna_transcript_id, hgvs_cdna_transcript_id_split, ensembl_transcript_id)
    full_current_version_hgvs_cdna_transcript_id = get_full_current_version_hgvs_cdna_transcript_id(current_version_hgvs_cdna_transcript_id, hgvs_cdna_transcript_id_split)
    grch38_variant_position = get_grch38_variant_position(full_current_version_hgvs_cdna_transcript_id)
    transcript_length, translation_length, total_exons, coding_exons, exon_number, coding_exons = get_transcript_details(ensembl_transcript_id, grch38_variant_position)
    ensembl_protein_id = get_ensembl_protein_id(ensembl_transcript_id)
    pfam_smart_protein_domains = get_pfam_smart_protein_domains(ensembl_protein_id)
    rsID = get_rsID(full_current_version_hgvs_cdna_transcript_id)
    cleaned_clinvar = get_clinvar(rsID)

    results_dict = {
        'Gene symbol': gene_symbol,
        'Report generated on': report_date,
        'Coding change': hgvs_cdna_transcript_id_split,
        'Full gene name': full_gene_name,
        'Cytogenetic band': cytogenetic_band,
        'High protein expression': high_protein_expression,
        'Current HGVS ID': current_version_hgvs_cdna_transcript_id,
        'Protein start': protein_start,
        'Protein end' : protein_end,
        'Amino acid change' : amino_acid_change,
        'Transcript length' : transcript_length, 
        'Translation length': translation_length,
        'Total exons' : total_exons,
        'Coding exons': coding_exons,
        'Exon number' : exon_number,
        'Protein domains (Sources: Pfam and Smart)': pfam_smart_protein_domains,
        'Clinvar': cleaned_clinvar
    }
    
    return results_dict

def curate_data_for_pdf(results_dict):
    styles = getSampleStyleSheet()
    curated_data = []

    for key, value in results_dict.items():
        if key == 'Gene symbol':
            curated_data.append(('title', {'text': f'Variant Report: {results_dict["Full gene name"].title()} ({results_dict["Gene symbol"]})', 'style': 'Title'}))

        elif key == 'Protein domains (Sources: Pfam and Smart)':
            table_data = [['Source', 'Description', 'Start', 'End']]
            for entry in value:
                table_data.append([
                    Paragraph(entry.get('Source', ''), styles['Normal']),
                    Paragraph(entry.get('Description', ''), styles['Normal']), 
                    Paragraph(entry.get('Start', ''), styles['Normal']),
                    Paragraph(entry.get('End', ''), styles['Normal']),
                ])
            curated_data.append(('protein_domains', {'data': table_data, 'columns': [100, 100, 100, 100]}))

        elif key == 'Clinvar':
            table_data = [['Classification', 'Condition', 'More info']]
            for entry in value:
                combined_info = Paragraph(
                    f"{entry.get('Condition', '')}<br/>{entry.get('Affected status', '')}<br/>{entry.get('Allele origin', '')}",
                    styles['Normal']
                )
                table_data.append([
                    Paragraph(entry.get('Variant classification', ''), styles['Normal']),
                    combined_info,
                    Paragraph(entry.get('Variant more info', ''), styles['Normal'])
                ])
            curated_data.append(('clinvar', {'data': table_data, 'columns': [100, 100, 200]}))

        else:
            curated_data.append((key, value))

    return curated_data

def append_story_elements(curated_data, order):
    styles = getSampleStyleSheet()
    story = []

    for key in order:
        for item in curated_data:
            if item[0] == key:
                if key == 'title':
                    title = Paragraph(item[1]['text'], styles[item[1]['style']])
                    story.append(title)
                    story.append(Spacer(1, 12))

                elif key == 'protein_domains':
                    table_data = item[1]['data']
                    table_style = TableStyle([
                        ('BACKGROUND', (0, 0), (-1, 0), colors.grey),
                        ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
                        ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
                        ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
                        ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
                        ('BACKGROUND', (0, 1), (-1, -1), colors.beige),
                        ('GRID', (0, 0), (-1, -1), 1, colors.black),
                        ('VALIGN', (0, 0), (-1, -1), 'TOP'),
                    ])
                    table = Table(table_data, colWidths=item[1]['columns'])
                    table.setStyle(table_style)
                    story.append(table)
                    story.append(Spacer(1, 12))

                elif key == 'clinvar':
                    table_data = item[1]['data']
                    table_style = TableStyle([
                        ('BACKGROUND', (0, 0), (-1, 0), colors.grey),
                        ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
                        ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
                        ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
                        ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
                        ('BACKGROUND', (0, 1), (-1, -1), colors.beige),
                        ('GRID', (0, 0), (-1, -1), 1, colors.black),
                        ('VALIGN', (0, 0), (-1, -1), 'TOP'),
                    ])
                    table = Table(table_data, colWidths=item[1]['columns'])
                    table.setStyle(table_style)
                    story.append(table)
                    story.append(Spacer(1, 12))

                else:
                    text = f'<b>{key}</b>: {item[1]}'
                    paragraph = Paragraph(text, styles['Normal'])
                    story.append(paragraph)
                    story.append(Spacer(1, 12))

    return story

def create_pdf_from_curated_data(story, filename):
    doc = SimpleDocTemplate(filename, pagesize=letter)
    elements = []
    styles = getSampleStyleSheet()

    available_height = letter[1] - doc.topMargin - doc.bottomMargin
    current_height = 0

    for element in story:
        if isinstance(element, Table):
            table_width, table_height = element.wrap(doc.width, doc.height)
            
            # Add a page break if the table does not fit on the remaining page
            if current_height + table_height > available_height:
                elements.append(PageBreak())
                current_height = 0
            
            elements.append(element)
            current_height += table_height
        
        elif isinstance(element, (Spacer, Paragraph)):
            element_width, element_height = element.wrap(doc.width, doc.height)
            
            # Add a page break if the element does not fit on the remaining page
            if current_height + element_height > available_height:
                elements.append(PageBreak())
                current_height = 0
            
            elements.append(element)
            current_height += element_height

    doc.build(elements)

html_template = """
<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css">
    <title>Variant Report Generator</title>
</head>
<body>
    <div class="container mt-5">
        <h1 class="text-center">Variant Report Generator</h1>
        <form method="post">
            <div class="form-group">
                <label for="hgvs_cdna_transcript_id">HGVS cDNA Transcript ID</label>
                <input type="text" class="form-control" id="hgvs_cdna_transcript_id" name="hgvs_cdna_transcript_id" placeholder="Enter HGVS cDNA Transcript ID" required>
            </div>
            <button type="submit" class="btn btn-primary">Generate Report</button>
        </form>
    </div>
</body>
</html>
"""

app = Flask(__name__)
@app.route('/', methods=['GET', 'POST'])
def index():
    if request.method == 'POST':
        hgvs_cdna_transcript_id = request.form['hgvs_cdna_transcript_id']
        results_dict = get_results_dict(hgvs_cdna_transcript_id)
        curated_data = curate_data_for_pdf(results_dict)
        ordered_keys = [
            'title',  
            'Report generated on', 
            'Current HGVS ID', 
            'Coding change', 
            'Amino acid change',
            'Protein start',
            'Protein end',
            'Cytogenetic band',
            'High protein expression',
            'Transcript length',  
            'Translation length',
            'Total exons', 
            'Coding exons',
            'Exon number',
            'protein_domains',
            'clinvar'
        ]
        story = append_story_elements(curated_data, ordered_keys)
        pdf_filename = 'output.pdf'
        create_pdf_from_curated_data(story, pdf_filename)
        return send_file(pdf_filename, as_attachment=True)
    return render_template_string(html_template)

def run_app():
    app.run()

threading.Thread(target=run_app).start()
